2)lex

%{
#include<stdio.h>
int wc=0,lc=0,sc=0,cc=0;
%}

%%
[\n] {lc++; cc+=yyleng;}
[ \t] {sc++; cc+=yyleng;}
[^ \t\n]+ {wc++; cc+=yyleng;}
%%

int main(){
printf("enter the input\n");
yylex();
printf("%d%d%d%d",lc,wc,sc,cc);
}

int yywrap(){
return 1;
}


3)Scanner
%{
#include<stdio.h>
int total=0;
%}

%%
#.* {total++; printf("This is a preprocessor directive: %s\n",yytext);}
"if"|"while"|"for" {total++; printf("This is a reserved keyword: %s\n",yytext);}
[_a-zA-z][a-zA-z0-9_] {total++; printf("This is a identifier: %s\n",yytext);}
[(){},;] {total++; printf("This is a separator: %s\n",yytext);}
[0-9] {total++; printf("This is a integer : %s\n",yytext);}
[0.-9.] {total++; printf("This is a float: %s\n",yytext);}

%%

int main(){
yylex();
printf("Total token count is: %d",total);
}
int yywrap(){
return 1;
}


4)bison
.l
%{
#include<stdio.h>
#include "y.tab.h"
extern int yylval;
%}

%%
[0-9]+ {
          yylval=atoi(yytext);
          return NUMBER;
       }
[\t] ;
[\n] return 0;
. return yytext[0];
%%

int yywrap()
{
return 1;
}


 //lex 4.l
//~$ bison -dy 4.y
//~$ gcc lex.yy.c 4.y
//./a.out

y:

%{
    #include<stdio.h>
    int flag=0;
%}

%token NUMBER
%left '+' '-'
%left '*' '/' '%'
%left '(' ')'
%%
ArithmeticExpression: E{
         printf("\nResult=%d\n",$$);
         return 0;
        };

E:E'+'E {$$=$1+$3;}
 |E'-'E {$$=$1-$3;}
 |E'*'E {$$=$1*$3;}
 |E'/'E {$$=$1/$3;}
 |E'%'E {$$=$1%$3;}
 |'('E')' {$$=$2;}
 | NUMBER {$$=$1;};

%%
void main()
{
   printf("\nEnter Any Arithmetic Expression which can have operations Addition, Subtraction, Multiplication, Divison, Modulus and Round brackets:\n");

   yyparse();
  if(flag==0)
   printf("\nEntered arithmetic expression is Valid\n\n");
}

void yyerror()
{
   printf("\nEntered arithmetic expression is Invalid\n\n");
   flag=1;
}

5a)


#include <iostream>
#include <vector>
#include <string>
using namespace std;

int main()
{

int n;
cout<<"\nEnter number of non terminals: ";
cin>>n;
cout<<"\nEnter non terminals one by one: ";
int i;
vector<string> nonter(n);
vector<int> leftrecr(n,0);
for(i=0;i<n;++i) {
cout<<"\nNon terminal "<<i+1<<" : ";
cin>>nonter[i];
}
vector<vector<string> > prod;
cout<<"\nEnter '^' for null";
for(i=0;i<n;++i) {
cout<<"\nNumber of "<<nonter[i]<<" productions: ";
int k;
cin>>k;
int j;
cout<<"\nOne by one enter all "<<nonter[i]<<" productions";
vector<string> temp(k);
for(j=0;j<k;++j) {
cout<<"\nRHS of production "<<j+1<<": ";
string abc;
cin>>abc;
temp[j]=abc;

if(nonter[i].length()<=abc.length()&&nonter[i].compare(abc.substr(0,nonter[i].length()))==0)
leftrecr[i]=1;
}
prod.push_back(temp);
}

for(i=0;i<n;++i) {
cout<<leftrecr[i];
}
for(i=0;i<n;++i) {
if(leftrecr[i]==0)
continue;
int j;
nonter.push_back(nonter[i]+"'");
vector<string> temp;
for(j=0;j<prod[i].size();++j) {

if(nonter[i].length()<=prod[i][j].length()&&nonter[i].compare(prod[i][j].substr(0,nonter[i].length
()))==0) {
string
abc=prod[i][j].substr(nonter[i].length(),prod[i][j].length()-nonter[i].length())+nonter[i]+"'";
temp.push_back(abc);
prod[i].erase(prod[i].begin()+j);
--j;
}
else {
prod[i][j]+=nonter[i]+"'";
}
}
temp.push_back("^");
prod.push_back(temp);
}
cout<<"\n\n";
cout<<"\nNew set of non-terminals: ";
for(i=0;i<nonter.size();++i)
cout<<nonter[i]<<" ";
cout<<"\n\nNew set of productions: ";

for(i=0;i<nonter.size();++i) {
int j;
for(j=0;j<prod[i].size();++j) {
cout<<"\n"<<nonter[i]<<" -> "<<prod[i][j];
}
}
return 0;
}

// Enter number of non terminals: 2
// Enter non terminals one by one:
// Non terminal 1: A
// Non terminal 2: B
// Enter '^' for null
// Number of A productions: 2
// One by one enter all A productions
// RHS of production 1: Axyz
// RHS of production 2: xABC
// Number of B productions: 1
// One by one enter all B productions
// RHS of production 1: AAB

5b)


#include <bits/stdc++.h>
#define max 20
using namespace std;
char prod[max][10], ter[10], nt[10], first[10][10], follow[10][10];
int eps[10],c=0;
int findpos(char ch)
{
    int n;
    for (n = 0; nt[n] != '\0'; n++)
        if (nt[n] == ch)
            break;
    if (nt[n] == '\0')
        return 1;
    return n;
}
int IsCap(char c)
{
    return (c >= 'A' && c <= 'Z') ? 1 : 0;
}
void add(char *arr, char c)
{
    int i, flag = 0;
    for (i = 0; arr[i] != '\0'; i++)
        if (arr[i] == c)
        {
            flag = 1;
            break;
        }
    if (flag != 1)
        arr[strlen(arr)] = c;
}
void addarr(char *s1, char *s2)
{
    int i, j, flag = 99;
    for (i = 0; s2[i] != '\0'; i++)
    {
        flag = 0;
        for (j = 0;; j++)
        {
            if (s2[i] == s1[j])
            {
                flag = 1;
                break;
            }
            if (j == strlen(s1) && flag != 1)
            {
                s1[strlen(s1)] = s2[i];
                break;
            }
        }
    }
}
void addprod(char *s)
{
    int i;
    prod[c][0] = s[0];
    for (i = 3; s[i] != '\0'; i++)
    {
        if (!IsCap(s[i]))
            add(ter, s[i]);
        prod[c][i - 2] = s[i];
    }
    prod[c][i - 2] = '\0';
    add(nt, s[0]);
    c++;
}
void findfirst()
{
    int i, j, n, k, e, n1;
    for (i = 0; i < c; i++)
    {
        for (j = 0; j < c; j++)
        {
            n = findpos(prod[j][0]);
            if (prod[j][1] == (char)238)
                eps[n] = 1;
            else
            {
                for (k = 1, e = 1; prod[j][k] != '\0' && e == 1; k++)
                {
                    if (!IsCap(prod[j][k]))
                    {
                        e = 0;
                        add(first[n], prod[j][k]);
                    }
                    else
                    {
                        n1 = findpos(prod[j][k]);
                        addarr(first[n], first[n1]);
                        if (eps[n1] == 0)
                            e = 0;
                    }
                }
                if (e == 1)
                    eps[n] = 1;
            }
        }
    }
}
void findfollow()
{
    int i, j, k, n, e, n1;
    n = findpos(prod[0][0]);
    add(follow[n], '#');
    for (i = 0; i < c; i++)
    {
        for (j = 0; j < c; j++)
        {
            for (k = strlen(prod[j]) - 1; k > 0; k--)
            {
                if (IsCap(prod[j][k]))
                {
                    n = findpos(prod[j][k]);
                    if (prod[j][k + 1] == '\0') // A -> aB
                    {
                        n1 = findpos(prod[j][0]);
                        addarr(follow[n], follow[n1]);
                    }
                    if (IsCap(prod[j][k + 1])) // A -> aBb
                    {
                        n1 = findpos(prod[j][k + 1]);
                        addarr(follow[n], first[n1]);
                        if (eps[n1] == 1)
                        {
                            n1 = findpos(prod[j][0]);
                            addarr(follow[n], follow[n1]);
                        }
                    }
                    else if (prod[j][k + 1] != '\0')
                        add(follow[n], prod[j][k + 1]);
                }
            }
        }
    }
}
int main()
{
    char s[max], i;
    cout << "\nEnter the productions (type 'end' at the last of the production)\n";
    cin >> s;
    while (strcmp("end", s))
    {
        addprod(s);
        cin >> s;
    }
    findfirst();
    findfollow();
    for (i = 0; i < strlen(nt); i++)
    {
        cout << "\nFIRST[" << nt[i] << "]: " << first[i];
        if (eps[i] == 1)
            cout << (char)238 << "\t";
        else
            cout << "\t";
        cout << "FOLLOW[" << nt[i] << "]: " << follow[i];
    }
    return 0;
}

// S->Abc
// A->aBC
// B->b
// C->c
// end


7)shift reduce parse?????


8)
import java.util.*;

class Student {
    private String name;
    private int id;
    private String fatherName;
    private String motherName;

    public Student(String name, int id, String fatherName, String motherName) {
        this.name = name;
        this.id = id;
        this.fatherName = fatherName;
        this.motherName = motherName;
    }

    public String getName() {
        return name;
    }

    public int getId() {
        return id;
    }

    public String getFatherName() {
        return fatherName;
    }

    public String getMotherName() {
        return motherName;
    }
}

public class StudentDatabase {
    private static List<Student> students = new ArrayList<>();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        int choice;

        do {
            System.out.println("Menu:");
            System.out.println("1. Register new student");
            System.out.println("2. Delete existing student");
            System.out.println("3. View all students");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");
            choice = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            switch (choice) {
                case 1:
                    registerStudent();
                    break;
                case 2:
                    deleteStudent();
                    break;
                case 3:
                    viewAllStudents();
                    break;
                case 4:
                    System.out.println("Exiting program...");
                    break;
                default:
                    System.out.println("Invalid choice. Please enter a number between 1 and 4.");
            }
        } while (choice != 4);
    }

    private static void registerStudent() {
        System.out.println("Enter student details:");
        System.out.print("Name: ");
        String name = scanner.nextLine();
        System.out.print("ID: ");
        int id = scanner.nextInt();
        scanner.nextLine(); // Consume newline
        System.out.print("Father's Name: ");
        String fatherName = scanner.nextLine();
        System.out.print("Mother's Name: ");
        String motherName = scanner.nextLine();

        students.add(new Student(name, id, fatherName, motherName));
        System.out.println("Student registered successfully.");
    }

    private static void deleteStudent() {
        System.out.print("Enter ID of student to delete: ");
        int id = scanner.nextInt();
        scanner.nextLine(); // Consume newline

        boolean found = false;
        Iterator<Student> iterator = students.iterator();
        while (iterator.hasNext()) {
            Student student = iterator.next();
            if (student.getId() == id) {
                iterator.remove();
                System.out.println("Student deleted successfully.");
                found = true;
                break;
            }
        }
        if (!found) {
            System.out.println("Student with ID " + id + " not found.");
        }
    }

    private static void viewAllStudents() {
        if (students.isEmpty()) {
            System.out.println("No students registered yet.");
        } else {
            System.out.println("List of students:");
            for (Student student : students) {
                System.out.println("Name: " + student.getName());
                System.out.println("ID: " + student.getId());
                System.out.println("Father's Name: " + student.getFatherName());
                System.out.println("Mother's Name: " + student.getMotherName());
                System.out.println();
            }
        }
    }
}

9)
import java.io.*;
import java.util.*;
class TreeNode {
String value;
TreeNode left;
TreeNode right;
TreeNode(String value) {
this.value = value;
this.left = null;
this.right = null;
}
}
public class SyntaxTreeTraversal {
public static int traverseAndCalculate(TreeNode node) {
if (node == null) {
return 0;
}
if (node.left == null && node.right == null) {
return Integer.parseInt(node.value);
}
int leftValue = traverseAndCalculate(node.left);
int rightValue = traverseAndCalculate(node.right);
switch (node.value) {
case "+":
return leftValue + rightValue;
case "-":
return leftValue - rightValue;
case "*":
return leftValue * rightValue;
case "/":
if (rightValue == 0) {
throw new ArithmeticException("Division by zero");
}
return leftValue / rightValue;
default:
throw new IllegalArgumentException("Invalid operator: " + node.value);
}
}
public static void main(String[] args) {
    Scanner sc=new Scanner(System.in);
// Example syntax tree: 3 + (5 * 2)
String a,b,c,d,e;
a=sc.nextLine();
b=sc.nextLine();
c=sc.nextLine();
d=sc.nextLine();
e=sc.nextLine();
TreeNode root = new TreeNode(b);
root.left = new TreeNode(a);
root.right = new TreeNode(d);
root.right.left = new TreeNode(c);
root.right.right = new TreeNode(e);
// Perform traversal and calculation
int result = traverseAndCalculate(root);
System.out.println("Result: " + result);
}
}

10)
import java.io.*;
import java.util.*;


public class intermediateCodeGenerator{
    private static int labelCount=0;

    public static String generateLabel() {
        labelCount++;  
        return "Label_" + labelCount;
    }
    
public static String generateCode(String condition, String action[]){
    String  ifCode="";
    String elseLabel=generateLabel();
    String endLabel=generateLabel();
    ifCode+="if"+condition+"goto"+elseLabel+";\n";
    for(String statement:action){
        ifCode+=statement+"\n";
    }
    ifCode+="goto"+endLabel+";\n";
    ifCode+=elseLabel+":\n";
    ifCode+=endLabel+":\n";
    return ifCode;
}

public static String generateWhileCode(String condition, String action[]){
    String whileCode="";
    String loopLabel=generateLabel();
    String endLabel=generateLabel();
    whileCode+=loopLabel+":\n ";
    whileCode+="if"+condition+"goto"+endLabel+";\n";
    for(String Statement:action){
        whileCode+=Statement+"\n";
    }
    return whileCode;
}
public static void main(String[]args){
    String[] ifStatement={"Statement 1;","Statement 2;"};
    String ifCode=generateCode("condition",ifStatement);
    System.out.println(ifCode);
    String[]whileStatement={"statement 1;","Statement 2;"};
    String whileCode=generateWhileCode("condition",whileStatement);
    System.out.println(whileCode);
    
}
}

11)
import java.io.*;
import java.util.*;

public class BooleanExpressionCodeGenerator {
    private static int labelCount = 0;

    public static String generateLabel() {
        labelCount++;
        return "Label_" + labelCount;
    }

    public static String generateBooleanExpressionCode(String expression) {
        String code = "";
        String trueLabel = generateLabel();
        String falseLabel = generateLabel();

        code += "if " + expression + " goto " + trueLabel + ";\n";
        code += "goto " + falseLabel + ";\n";
        code += trueLabel + ":\n";
        code += "    result = true;\n";
        code += falseLabel + ":\n";
        code += "    result = false;\n";

        return code;
    }

    public static void main(String[] args) {
        String booleanExpression = "(a & b) || (c&d)";
        String generatedCode = generateBooleanExpressionCode(booleanExpression);
        System.out.println("Generated Code:");
        System.out.println(generatedCode);
    }
}

12)
.data
    number1: .word 5
    number2: .word 8
    newline: .asciiz "\n"
.text
    .globl main

main:
    lw $t0, number1
    lw $t1, number2
    add $t2, $t0, $t1

    li $v0, 1
    move $a0, $t2
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    li $v0, 10
    syscall


#spim -file 12.asm